<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Web Chat">
    <meta itemprop="description" content="University Of Lagos Web Chat">
    <meta itemprop="name" content="Home Chat">

    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">

    <title>Home</title>
</head>

<body>
    <div id="app">
        <v-app>
            <v-main>
                <template v-if="callSession===false">
                    <template v-if=" $vuetify.breakpoint.smAndDown">
                        <v-row style="height: 100%;" no-gutters>
                            <v-col cols="auto">
                                <v-card height="100%">
                                    <v-navigation-drawer :mini-variant="mini" :expand-on-hover="expand" permanent>
                                        <v-list dense nav class="py-0">
                                            <v-list-item two-line class="px-1">
                                                <v-icon @click="drawer=true">mdi-menu</v-icon>
                                            </v-list-item>

                                            <v-divider></v-divider>
                                            <v-list-item></v-list-item>

                                            <v-list-item>
                                                <v-badge overlap color="red" :content="messages.length"
                                                    :value="messages.length">
                                                    <v-icon @click="openMessageDialog=true">mdi-email</v-icon>
                                                </v-badge>
                                                <v-dialog scrollable v-model="openMessageDialog" width="600px">
                                                    <v-card>
                                                        <v-card-title>Messages</v-card-title>
                                                        <v-divider></v-divider>
                                                        <v-card-text style="max-height: 500px;">
                                                            <v-container>
                                                                <span v-if="messages.length==0">No Message</span>
                                                                <v-row>
                                                                    <v-col v-for="(message,i) in messages" :key="i"
                                                                        cols="12">
                                                                        <span>{{message.requestingUserName}}
                                                                            ({{message.requestingUserID}}) wants to add
                                                                            you
                                                                            to a room ({{message.roomName}})</span>
                                                                        <v-spacer></v-spacer>
                                                                        <v-btn color="green darken-1"
                                                                            @click="acceptJoinRequest(message.roomID,message.roomName,i)"
                                                                            text>Accept</v-btn>
                                                                        <v-btn color="green darken-1" text>Decline
                                                                        </v-btn>
                                                                    </v-col>
                                                                </v-row>
                                                            </v-container>
                                                        </v-card-text>
                                                    </v-card>
                                                </v-dialog>
                                            </v-list-item>

                                            <v-list-item>
                                                <v-badge overlap color="white" value=0>
                                                    <v-icon @click="createRoomDialog=true">mdi-plus</v-icon>
                                                </v-badge>
                                                <v-dialog v-model="createRoomDialog">
                                                    <v-card>
                                                        <v-card-text>
                                                            <v-container fluid>
                                                                <v-row>
                                                                    <v-col cols="12">
                                                                        <span>Create New Room</span>
                                                                    </v-col>
                                                                    <v-col cols="12">
                                                                        <v-text-field label="Specify Room Name"
                                                                            v-model="newRoomName"
                                                                            @keyup.enter.exact="getUsers">
                                                                        </v-text-field>
                                                                    </v-col>
                                                                    <v-col cols="12">
                                                                        <v-spacer></v-spacer>
                                                                        <v-btn @click="createRoom(newRoomName)"
                                                                            color="green darken-1" text>
                                                                            Create Room</v-btn>
                                                                    </v-col>
                                                                </v-row>
                                                            </v-container>
                                                        </v-card-text>
                                                    </v-card>
                                                </v-dialog>
                                            </v-list-item>

                                            <v-list-item>
                                                <v-badge overlap color="red"
                                                    :content="Object.keys(onreadRoomMessageCount).length"
                                                    :value="Object.keys(onreadRoomMessageCount).length">
                                                    <v-icon>mdi-account-group-outline</v-icon>
                                                </v-badge>
                                            </v-list-item>
                                        </v-list>
                                    </v-navigation-drawer>
                                </v-card>
                                <v-navigation-drawer v-model="drawer" absolute temporary>
                                    <side-bar :rooms="rooms" :chatspreview="chatspreview"
                                        @update-current-chat-contents-loaded="loadChatContent"
                                        :onreadroommessagecount="onreadRoomMessageCount" />
                                </v-navigation-drawer>
                            </v-col>

                            <v-col cols="mx-auto">
                                <chatting-component :currentchatcontentsloaded="currentChatContentsNotLoaded"
                                    :currentchatcontent="currentChatContent" :currentviewedroomid="currentViewedRoomID"
                                    :currentviewedroomname="currentViewedRoomName"
                                    :removewelcomepage="removeWelcomePage" :onlineusers="onlineUsers"
                                    :usersfound="usersFound" :downloadinfo="downloadInfo" />
                            </v-col>
                        </v-row>
                    </template>

                    <template v-else>
                        <v-row style="height: 100%;" no-gutters>
                            <v-col cols="auto">
                                <side-bar :rooms="rooms" :chatspreview="chatspreview"
                                    @update-current-chat-contents-loaded="loadChatContent"
                                    @accept-join-request="acceptJoinRequest" :messages="messages"
                                    :createroomdialog="createRoomDialog" @create-room="createRoom"
                                    :onreadroommessagecount="onreadRoomMessageCount" />
                            </v-col>
                            <v-divider vertical></v-divider>
                            <v-col cols="mx-auto">
                                <chatting-component :currentchatcontentsloaded=" currentChatContentsNotLoaded"
                                    :currentchatcontent="currentChatContent" :currentviewedroomid="currentViewedRoomID"
                                    :currentviewedroomname="currentViewedRoomName"
                                    :removewelcomepage="removeWelcomePage" :onlineusers="onlineUsers"
                                    :usersfound="usersFound" :downloadinfo="downloadInfo" />
                            </v-col>
                        </v-row>
                    </template>

                    <v-dialog persistent width="400px" v-model="socketClosed">
                        <v-card>
                            <v-card-text>
                                <div align="center" justify="center">
                                    <v-row>
                                        <v-col cols="12">
                                            <v-progress-circular indeterminate color="green"></v-progress-circular>
                                        </v-col>
                                        <v-col cols="12">
                                            <span>Websocket disconnected. Reconnecting.</span>
                                        </v-col>
                                    </v-row>
                                </div>
                            </v-card-text>
                        </v-card>
                    </v-dialog>
                </template>

                <template v-else>
                    <call-ui :caller_names="callerNames" :caller_name_initials="callerNameInitials" />
                </template>
            </v-main>
        </v-app>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/core.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/sha256.js"></script>

    <script>
        Vue.component('call-ui', {
            props: {
                caller_name_initials: String,
                caller_names: String,
            },

            data: function () {
                return {
                    showVideoOptions: true,
                    audioOn: true,
                    videoOn: true,
                    fullScreen: false,
                    isDesktopShared: false,

                    videoIcon: "mdi-video",
                    audioIcon: "mdi-microphone",
                    screenMode: "mdi-fullscreen",
                }
            },

            methods: {
                endCall: function () {
                    this.fullScreen = false
                    this.isDesktopShared = false
                    this.audioOn = true
                    this.videoOn = true

                    this.videoIcon = "mdi-video"
                    this.audioIcon = "mdi-microphone"
                    this.screenMode = "mdi-fullscreen"

                    vueComponent.callSession = false
                    endClassSession(vueComponent.currentViewedRoomID)
                },


                requestFullScreen: function () {
                    if (!document.fullscreenElement) {
                        document.documentElement.requestFullscreen();
                    } else if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }

                    this.fullScreen = !this.fullScreen
                },

                changeAudioStatus: function () {
                    if (this.audioOn) {
                        this.audioIcon = 'mdi-microphone-off'
                    } else {
                        this.audioIcon = 'mdi-microphone'
                    }

                    this.audioOn = !this.audioOn
                    changeAudio(this.audioOn)
                },

                changeVideoStatus: function () {
                    if (this.videoOn) {
                        this.videoIcon = 'mdi-video-off'
                        this.isDesktopShared = false
                    } else {
                        this.videoIcon = 'mdi-video'
                    }

                    this.videoOn = !this.videoOn
                    changeVideo(this.videoOn)
                },

                desktopShare: function () {
                    // Do not enable screen share if video is disabled.
                    if (!this.videoOn) {
                        return
                    }

                    console.log("Starting desktop share")
                    if (!this.isDesktopShared) {
                        startDesktopSharing()
                    } else {
                        startDesktopSharing()
                    }

                    this.isDesktopShared = !this.isDesktopShared
                }
            },

            template: `(% template "callUI" .%)`,
        })

        Vue.component('side-bar', {
            props: {
                rooms: Array,
                chatspreview: {},
                messages: Array,
                onreadroommessagecount: {},
            },

            data: function () {
                return {
                    newRoomName: '',
                    createRoomDialog: false,
                    openMessageDialog: false,
                    name: '(%.Name%)',
                }
            },

            methods: {
                loadChatContent: function (chatID) {
                    this.$emit("update-current-chat-contents-loaded", chatID);
                },

                acceptJoinRequest: function (roomID, roomName, notificationIndex) {
                    this.$emit("accept-join-request", roomID, roomName, notificationIndex);
                },

                createRoom: function () {
                    this.$emit("create-room", this.newRoomName);
                    this.newRoomName = ""
                    this.createRoomDialog = false
                },

            },

            template: `(% template "sidebar" .%)`,
        })

        Vue.component('chatting-component', {
            props: {
                removewelcomepage: Boolean,
                currentchatcontentsloaded: Boolean,
                currentchatcontent: Array,
                currentviewedroomid: String,
                currentviewedroomname: String,
                onlineusers: {},
                downloadinfo: Object,
                usersfound: Array,
            },

            data: function () {
                return {
                    addUserDialog: false,
                    showRoomUsersDialog: false,
                    addedUsers: [],
                    selected: [],
                    messageContent: '',
                    searchUserTextValue: '',
                    searchText: '',
                    uuid: '(%.UUID %)',
                    userID: '(%.Email %)',
                    userName: '(%.Name %)',
                }
            },

            methods: {
                startClassSession: function () {
                    vueComponent.callSession = true
                    vueComponent.isPublisher = true
                    startClassVideoSession()
                },

                joinClassSession: function (sessionData) {
                    vueComponent.callSession = true
                    vueComponent.isPublisher = false
                    joinClassSession(sessionData)
                },

                sendMessage: function () {
                    if (!this.messageContent.match(/\S/))
                        return

                    // Send file if indicated.
                    if (vueComponent.fileContent !== null && vueComponent.fileContent.name === this.messageContent) {
                        if (vueComponent.fileContent.size > 256 * 1024 * 1024) {
                            // TODO: Show file too large dialog instead.
                            console.log("file too large");
                            this.messageContent = ""

                            return
                        }

                        var chunkSize = 125 * 1024;
                        var chunks = Math.ceil(vueComponent.fileContent.size / chunkSize, chunkSize);
                        var fileSize = this.bytesToSize(vueComponent.fileContent.size)
                        var fileName = vueComponent.fileContent.name;
                        var fileType = vueComponent.fileContent.type

                        if (vueComponent.downloadInfo[fileName] === undefined) {
                            vueComponent.downloadInfo[fileName] = {
                                "roomID": this.currentviewedroomid,
                                "progress": 0,
                                "completed": false,
                                "downloading": true,
                                "downloadType": "upload",
                                "fileSize": fileSize,
                                "fileType": fileType,
                                "fileContent": vueComponent.fileContent,
                                "chunk": 0,
                                "chunks": chunks,
                            }
                        }

                        var reader = new FileReader();
                        reader.onloadend = function (event) {
                            var data = event.target.result;

                            // We are to experiment splicing file with this same experiment.
                            var fileUniqueHash = CryptoJS.SHA256(data).toString();
                            vueComponent.downloadInfo[fileName].fileHash = fileUniqueHash

                            // Send new file upload information to server, indicating file information.
                            var message = {
                                "fileName": fileName,
                                "fileHash": fileUniqueHash,
                                "fileSize": fileSize,
                                "fileType": fileType,
                                "msgType": "NewFileUpload",
                                "userID": '(%.Email%)',
                            }

                            socket.send(JSON.stringify(message))
                        };
                        reader.readAsDataURL(vueComponent.fileContent);

                        // Update chat content or upload report.
                        vueComponent.currentChatContent.push({
                            "type": "upload",
                            "userID": '(%.Email%)',
                            "message": vueComponent.fileContent.name,
                            "name": '(%.Name%)',
                            "fileSize": fileSize,
                        })
                        scrollChatToBottom()

                        this.messageContent = ""
                        return
                    }

                    var message = {
                        "msgType": "NewMessage",
                        "roomID": this.currentviewedroomid,
                        "message": this.messageContent,
                        "userID": '(%.Email%)', "name": '(%.Name%)',
                        "type": "txt",
                    }

                    socket.send(JSON.stringify(message))
                    this.messageContent = ''
                },

                exitRoom: function () {
                    var message = {
                        "msgType": "ExitRoom",
                        "roomID": this.currentviewedroomid,
                        "email": '(%.Email %)',
                    }

                    socket.send(JSON.stringify(message))
                    this.showRoomUsersDialog = false
                },

                getUsers: function () {
                    var message = {
                        "msgType": "SearchUser",
                        "searchText": this.searchText,
                    }

                    socket.send(JSON.stringify(message))
                },

                closeSearchDialog: function () {
                    this.searchText = ''
                    this.addUserDialog = false
                    this.addedUsers = []
                    vueComponent.usersFound = []
                },

                requestUsersToJoinRoom: function () {
                    if (this.addedUsers.length === 0) {
                        return
                    }

                    var message = {
                        "msgType": 'RequestUsersToJoinRoom',
                        "users": this.addedUsers,
                        "roomID": this.currentviewedroomid,
                        "roomName": this.currentviewedroomname,
                        "requestingUserName": this.userName,
                        "requestingUserID": this.userID,
                    }

                    message = JSON.stringify(message)
                    socket.send(message)
                    this.closeSearchDialog()
                },

                startDownload: function (id, fileHash) {
                    if (vueComponent.downloadInfo[id] === undefined) {
                        vueComponent.downloadInfo[id] = {
                            "fileName": id,
                            "fileType": "",
                            "progress": 0,
                            "completed": false,
                            "downloading": false,
                            "downloadType": "download",
                            "fileContent": [],
                            "fileHash": fileHash,
                            "chunk": 0,
                            "chunks": 0,
                            "roomID": this.currentviewedroomid,
                        }
                    }

                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

                    // Request from server, next file chunk also indicating recent chunk hash.
                    // If recentChunkHash is an empty string it indicates a new download, else next file chunk
                    // is requested.
                    var message = {
                        "userID": vueComponent.userID,
                        "msgType": "RequestDownload",
                        "fileName": id,
                        "fileHash": vueComponent.downloadInfo[id].fileHash,
                    }

                    socket.send(JSON.stringify(message))
                },

                stopDownload: function (id) {
                    vueComponent.downloadInfo[id].downloading = false
                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])
                },

                stopUpload: function (id) {
                    vueComponent.downloadInfo[id].downloading = false
                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])
                },

                startUpload: function (id) {
                    vueComponent.downloadInfo[id].downloading = true
                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

                    // Re-request New file upload if upload was interrupted.
                    var message = {
                        "fileName": id,
                        "fileHash": vueComponent.downloadInfo[id].fileHash,
                        "fileSize": vueComponent.downloadInfo[id].fileSize,
                        "fileType": vueComponent.downloadInfo[id].fileType,
                        "msgType": "NewFileUpload",
                        "userID": '(%.Email%)',
                    }

                    socket.send(JSON.stringify(message))
                },

                bytesToSize: function (bytes) {
                    var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
                    if (bytes == 0) return '0 Byte';
                    var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
                    return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[i];
                },

                onFileUpdate: function (e) {
                    var files = e.target.files || e.dataTransfer.files;
                    if (!files.length)
                        return;

                    vueComponent.fileContent = files[0]
                    this.messageContent = vueComponent.fileContent.name
                },

                openFileDialog: function () {
                    document.getElementById('myFileInput').click()
                }
            },

            computed: {
                disableTextField: function () {
                    if (this.messageContent !== null && this.messageContent.length > 1
                        && vueComponent.fileContent !== null) {
                        return true
                    }

                    vueComponent.fileContent = null
                    return false
                }
            },

            template: `(% template "chattingComponent". %)`,
        })

        var vueComponent = new Vue({
            el: '#app',
            data: {
                rooms: [],
                messages: [],
                onreadRoomMessageCount: {},
                currentChatContentsNotLoaded: false,
                createRoomDialog: false,
                openMessageDialog: false,
                removeWelcomePage: false,
                currentViewedRoomID: '',
                currentViewedRoomName: '',
                userID: '(%.Email %)',
                chatspreview: {},
                currentChatContent: [],
                usersFound: [],
                onlineUsers: {},
                downloadCount: 0,
                downloadInfo: {},
                fileContent: null,

                drawer: false,
                socketClosed: false,
                expand: false,
                mini: true,

                callerNameInitials: "",
                callerNames: '',
                videoCallData: {},
                isPublisher: false,
                callSession: false,
            },

            methods: {
                addToRoomNotification: function (roomID) {
                    if (this.onreadRoomMessageCount[roomID] === undefined) {
                        this.onreadRoomMessageCount[roomID] = 1
                    } else {
                        this.onreadRoomMessageCount[roomID]++
                    }
                },

                removeFromRoomNotification: function (roomID) {
                    if (this.onreadRoomMessageCount[roomID] === undefined || this.onreadRoomMessageCount[roomID] === null) {
                        return
                    }

                    delete this.onreadRoomMessageCount[roomID]
                },

                loadChatContent: function (roomID) {
                    this.removeWelcomePage = true
                    this.currentChatContentsNotLoaded = true
                    var message = {
                        'msgType': 'RequestAllMessages',
                        "roomID": roomID
                    }
                    socket.send(JSON.stringify(message))
                    this.currentViewedRoomID = roomID
                },

                removeMessage: function (notificationIndex) {
                    this.messages.splice(notificationIndex, 1)
                },

                createRoom: function (roomName) {
                    var jsonContent = {
                        "email": this.userID,
                        "msgType": "NewRoomCreated",
                        "roomName": roomName
                    };

                    jsonContent = JSON.stringify(jsonContent);
                    socket.send(jsonContent);
                    this.createRoomDialog = false;
                    roomName = ""
                },

                acceptJoinRequest: function (roomID, roomName, notificationIndex) {
                    var message = {
                        "joined": true,
                        "roomID": roomID,
                        "roomName": roomName,
                        "msgType": "UserJoinedRoom",
                        "email": '(%.Email %)',
                    }

                    socket.send(JSON.stringify(message))
                    this.openMessageDialog = false
                    this.removeMessage(notificationIndex);
                },


            },

            vuetify: new Vuetify(),
        })

    </script>

    <script>
        var onMessage = function (e) {
            const jsonContent = JSON.parse(e.data);
            const msgType = jsonContent.msgType;

            switch (msgType) {
                case "UserJoinedRoom":
                    onUserJoinedRoom(jsonContent);
                    break

                case "RequestAllMessages":
                    onRquestAllMessages(jsonContent);
                    break

                case "RequestUsersToJoinRoom":
                    onUserJoined(jsonContent);
                    break

                case "NewMessage":
                    onMessageReceived(jsonContent);
                    break

                case "WebsocketOpen":
                    onSocketOpened(jsonContent);
                    break

                case "OnlineStatus":
                    if (vueComponent.onlineUsers[jsonContent.username] !== undefined) {
                        vueComponent.onlineUsers[jsonContent.username] = jsonContent.status;
                        Vue.set(vueComponent.rooms, 0, vueComponent.rooms[0]);
                    };
                    break

                case "ExitRoom":
                    var message = jsonContent.email + " exited room";
                    if (jsonContent.email === '(%.Email %)') {
                        message = "You exited room";
                    };

                    if (jsonContent.roomID === vueComponent.currentViewedRoomID) {
                        vueComponent.currentChatContent.push({
                            "type": "info",
                            "message": message
                        });
                    };
                    break

                case "getUsers":
                    vueComponent.usersFound = jsonContent.UsersFound;
                    break

                case "UploadFileChunk":
                    onUploadFileChunk(jsonContent);
                    break

                case "UploadError":
                    // On UploadErrror, stop download so user have to re-upload from corrupted stage.
                    var id = jsonContent.fileName
                    vueComponent.downloadInfo[id].completed = false
                    vueComponent.downloadInfo[id].downloading = false
                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])
                    break

                case "FileUploadSuccess":
                    if (jsonContent.roomID === vueComponent.currentViewedRoomID && jsonContent.userID !== '(%.Email%)') {
                        var id = jsonContent.fileName
                        vueComponent.currentChatContent.push({
                            "type": "file",
                            "name": jsonContent.name,
                            "message": jsonContent.fileName,
                            "fileSize": jsonContent.fileSize,
                            "fileName": jsonContent.fileName,
                            "fileHash": jsonContent.fileHash,
                            "userID": jsonContent.userID,
                        })

                        scrollChatToBottom()
                    }
                    break

                case "RequestDownload":
                    onRequestDownload(jsonContent)
                    break

                case "DownloadFileChunk":
                    onDownloadFileChunk(jsonContent)
                    break

                case "DownloadFileError":
                    var id = jsonContent.fileName;
                    vueComponent.downloadInfo[id].downloading = false;
                    Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0]);
                    break

                case "ClassSession":
                    // Create a session description if you are the author else broadcast in room.
                    // It is also used to negotiate offer.
                    if (jsonContent.userID === vueComponent.userID) {
                        console.log("Accepting remote description")
                        try {
                            peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: jsonContent.sdp }))
                        } catch (e) {
                            console.log(e)
                            // ToDo: Have a popup that shows error.
                        }

                    } else if (jsonContent.roomID === vueComponent.currentViewedRoomID) {
                        vueComponent.currentChatContent.push({
                            "type": "classSession",
                            "name": jsonContent.name,
                            "userID": jsonContent.userID,
                            "fileHash": jsonContent.sessionID, // FileHash represents the sdp.
                        })
                    }

                    break

                case "Negotiate":
                    if (peerConnection) {
                        console.log("Negotiating")
                        try {
                            peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: jsonContent.sdp }))
                        } catch (e) {
                            console.log(e)
                            // ToDo: Have a popup that shows error.
                        }
                    }
                    break

                case "Renegotiate":
                    sessionID = jsonContent.sessionID
                    renegotiate()

                    break
            }
        };
    </script>

    <script>
        var peerConnection = new RTCPeerConnection({
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                }
            ]
        })

        var stream = new MediaStream()
        var sessionID = ''

        var renegotiate = function () {
            if (peerConnection && sessionID !== '') {
                peerConnection.createOffer().
                    then(function (sdp) {
                        peerConnection.setLocalDescription(sdp)

                        var message = {
                            "msgType": "NegotiateSDP",
                            "sessionID": sessionID,
                            "sdp": sdp.sdp,
                            "userID": vueComponent.userID,
                        }

                        socket.send(JSON.stringify(message))
                    })
            }
        }

        var startClassVideoSession = function () {
            peerConnection = new RTCPeerConnection({
                iceServers: [
                    {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                ]
            })

            vueComponent.callerNameInitials = ''
            vueComponent.callerNames = '(%.Name %)'
            var str = vueComponent.callerNames.split(' ')

            for (var i = 0; i < str.length; i++)
                if (str[i].length > 0)
                    vueComponent.callerNameInitials += str[i][0]

            peerConnection.oniceconnectionstatechange = function () {
                console.log(peerConnection.iceConnectionState)
                if (peerConnection.iceConnectionState === "disconnected") {
                    peerConnection.close()
                    vueComponent.callSession = false
                }
            }

            peerConnection.onicecandidate = event => {
                if (event.candidate === null) {
                    console.log(peerConnection.localDescription.sdp);
                    var message = {
                        "msgType": "StartClassSession",
                        "sdp": peerConnection.localDescription.sdp,
                        "roomID": vueComponent.currentViewedRoomID,
                        "userID": vueComponent.userID,
                        "authorName": vueComponent.callerNames,
                    }

                    socket.send(JSON.stringify(message));
                }
            }

            peerConnection.onnegotiationneeded = function (e) {
                console.log("Negotiation needed", e)
            }

            var mediaConstraints = { video: true, audio: true }

            getUserMedia(mediaConstraints, function (e) {
                stream.addTrack(e.getVideoTracks()[0])

                peerConnection.addTransceiver(e.getAudioTracks()[0], { direction: "sendonly" })
                peerConnection.addTransceiver(e.getVideoTracks()[0], { direction: "sendonly" })
                var el = document.getElementById("videoID")

                el.srcObject = stream
                el.autoplay = true

                peerConnection.createOffer()
                    .then(d => peerConnection.setLocalDescription(d))
                    .catch(log => console.log(log))
            })

            // ToDo: I passed transceiver so that I can get stream content.
            // We can later add features to both use desktop and webcam sharing at same time.
            // ToDo: Detect if webcam is disable and show caller initials.
            peerConnection.ontrack = function ({ transceiver, streams: [event] }) {
                console.log(transceiver)
                var el = document.getElementById("videoID")
                stream.addTrack(transceiver.receiver.track)

                // ToDo: can we instead pass event to srcObject??
                el.srcObject = stream
                el.autoplay = true
            }
        }

        var joinClassSession = function (sessionData) {
            vueComponent.callerNameInitials = ''
            vueComponent.callerNames = sessionData.name
            var str = vueComponent.callerNames.split(' ')

            for (var i = 0; i < str.length; i++)
                if (str[i].length > 0)
                    vueComponent.callerNameInitials += str[i][0]

            peerConnection = new RTCPeerConnection({
                iceServers: [
                    {
                        urls: 'stun:stun.l.google.com:19302'
                    }
                ]
            })

            peerConnection.oniceconnectionstatechange = function () {
                console.log(peerConnection.iceConnectionState)
                if (peerConnection.iceConnectionState === "disconnected") {
                    peerConnection.close()
                    vueComponent.callSession = false
                }
            }

            peerConnection.onnegotiationneeded = event => {
                console.log("negotiation needed", event)
            }

            peerConnection.onicecandidate = event => {
                if (event.candidate === null) {
                    console.log(peerConnection.localDescription.sdp);
                    var message = {
                        "msgType": "JoinClassSession",
                        "sdp": peerConnection.localDescription.sdp,
                        "roomID": vueComponent.currentViewedRoomID,
                        "userID": vueComponent.userID,
                        "author": sessionData.userID,
                        "sessionID": sessionData.fileHash,
                    }

                    socket.send(JSON.stringify(message));
                }
            }

            var onMedia = function (e) {
                var audioTracks = e.getAudioTracks()

                peerConnection.addTransceiver(audioTracks[0], { direction: "sendonly" })

                console.log(peerConnection.getTransceivers())

                peerConnection.createOffer()
                    .then(d => peerConnection.setLocalDescription(d))
                    .catch(log => console.log(log))
            }

            var mediaConstraints = { audio: true }

            getUserMedia(mediaConstraints, onMedia)

            peerConnection.ontrack = function ({ transceiver, streams: [event] }) {
                console.log(transceiver)
                var el = document.getElementById("videoID")

                stream.addTrack(transceiver.receiver.track)
                el.srcObject = stream
                el.autoplay = true
            }
        }

        var endClassSession = function (room_ID) {
            var tracks = stream.getAudioTracks()
            removeTrack(tracks)

            tracks = stream.getVideoTracks()
            removeTrack(tracks)
            peerConnection.close()
        }

        var startDesktopSharing = function () {
            var mediaConstraints = { video: true }

            navigator.mediaDevices.getDisplayMedia(mediaConstraints)
                .then(function (e) {
                    var tracks = stream.getVideoTracks()
                    removeTrack(tracks)

                    tracks = e.getVideoTracks()
                    addTrack(tracks)
                })
                .catch(function (error) {
                    console.log(error)
                })
        }

        var stopDesktopSharing = function () {
            var mediaConstraints = { video: { width: { max: 640 }, height: { max: 480 } }, audio: true }

            var onMedia = function (e) {
                var tracks = stream.getAudioTracks()
                removeTrack(tracks)

                tracks = stream.getVideoTracks()
                removeTrack(tracks)

                var tracks = e.getAudioTracks()
                addTrack(tracks)

                tracks = e.getVideoTracks()
                addTrack(tracks)
            }

            getUserMedia(mediaConstraints, onMedia)
        }

        var changeAudio = function (start_audio) {
            if (!start_audio) {
                var tracks = stream.getAudioTracks()
                removeTrack(tracks)

                return
            }

            var onMedia = function (e) {
                var tracks = e.getAudioTracks()
                addTrack(tracks)
            }

            getUserMedia({ audio: true, video: false }, onMedia)
        }

        var changeVideo = function (startVideo) {
            if (!startVideo) {
                var tracks = stream.getVideoTracks()
                removeTrack(tracks)

                return
            }

            var onMedia = function (e) {
                var tracks = e.getVideoTracks()
                addTrack(tracks)
                document.getElementById("videoID").srcObject = stream
            }

            getUserMedia({ audio: false, video: true }, onMedia)
        }

        var getUserMedia = function (mediaOptions, onMedia) {
            navigator.mediaDevices.getUserMedia(mediaOptions)
                .then(function (e) {
                    onMedia(e)
                })
                .catch(function (error) {
                    console.log("something bad happened", error);
                })
        }

        var removeTrack = function (tracks) {
            for (var i = 0; i < tracks.length; i++) {
                tracks[0].stop()
                stream.removeTrack(tracks[i])
            }
        }

        var addTrack = function (tracks) {
            for (var i = 0; i < tracks.length; i++) {
                stream.addTrack(tracks[i])
            }
        }
    </script>

    <script>
        var socket

        var connectWebsocket = function () {
            console.log("trying to open ws")
            var endpoint = "ws://"
            if (document.location.protocol === "https:") {
                endpoint = "wss://"
            }
            socket = new WebSocket(endpoint + document.location.host + "/ws");

            socket.onopen = function () {
                console.log("websocket open")
                var msg = JSON.stringify({ msgType: "WebsocketOpen" })
                socket.send(msg)

                if (vueComponent.currentViewedRoomID !== "") {
                    var message = {
                        'msgType': 'RequestAllMessages',
                        "roomID": vueComponent.currentViewedRoomID,
                    }

                    socket.send(JSON.stringify(message))
                }
            };

            socket.onclose = function (e) {
                vueComponent.socketClosed = true
                setTimeout(() => {
                    connectWebsocket()
                }, (5000));
            }

            socket.onmessage = onMessage
        }

        console.log("starting up WS")
        connectWebsocket()
    </script>


    <script>
        var playAudio = new Audio('./assets/notification.mp3');

        var scrollChatToBottom = function () {
            if (vueComponent.callSession === true || vueComponent.removeWelcomePage == false) {
                return
            }

            setTimeout(() => {
                var chatcontent = document.getElementById("chatcontent");
                chatcontent.scrollTop = chatcontent.scrollHeight
            }, 0)
        }

        var onUserJoinedRoom = function (msg) {
            var roomID = msg.roomID;
            var roomName = msg.roomName;

            var message = msg.email + " Joined";
            if (msg.email === '(%.Email %)') {
                message = "You Joined";
            }

            vueComponent.chatspreview[roomID] = { "message": message, "roomName": roomName }

            // Append to rooms option if same user joined else notify others in room.
            if (msg.email === '(%.Email %)') {
                vueComponent.rooms.push(roomID)
            } else {
                Vue.set(vueComponent.rooms, 0, vueComponent.rooms[0])
            }

            // Only update current chat if in view.
            if (vueComponent.currentViewedRoomID === roomID) {
                vueComponent.currentChatContent.push({ "type": "info", "message": msg.email + " Joined the room" })
            }

            vueComponent.addToRoomNotification(roomID)
            Vue.set(vueComponent.rooms, 0, vueComponent.rooms[0])
            playAudio.play();
        }

        var onRquestAllMessages = function (msg) {
            vueComponent.onlineUsers = msg.onlineUsers

            if (msg.messages === null) {
                vueComponent.currentChatContent = []
            } else {
                vueComponent.currentChatContent = msg.messages
            }

            // Show download progress.
            for (const id in vueComponent.downloadInfo) {
                if (vueComponent.downloadInfo[id].roomID === vueComponent.currentViewedRoomID && !vueComponent.downloadInfo[id].completed
                    && vueComponent.downloadInfo[id].downloadType === "upload") {
                    vueComponent.currentChatContent.push({
                        "type": "upload",
                        "userID": '(%.Email%)',
                        "message": id,
                        "name": '(%.Name%)',
                        "fileSize": vueComponent.downloadInfo[id].fileSize,
                    })
                }
            }

            vueComponent.currentViewedRoomName = msg.roomName
            vueComponent.currentChatContentsNotLoaded = false

            vueComponent.removeFromRoomNotification(msg.roomID)

            scrollChatToBottom()
        }

        var onUserJoined = function (msg) {
            if (msg.userRequested === '(%.Email %)') {
                var message = {
                    "requestingUserName": msg.requesterID,
                    "requestingUserID": msg.requesterName,
                    "roomName": msg.roomName,
                    "roomID": msg.roomID,
                }

                vueComponent.messages.push(message)
                vueComponent.addToRoomNotification(msg.roomID)

            } else {
                if (msg['roomID'] === vueComponent.currentViewedRoomID) {
                    vueComponent.currentChatContent.push({
                        "type": "info",
                        "message": msg.userRequested + " Requested to join room by" + msg.requesterID
                    })

                } else {
                    vueComponent.addToRoomNotification(msg.roomID)
                }

                vueComponent.chatspreview[msg.roomID] = {
                    "message": msg.userRequested + " Requested to join the room by " + msg.requesterID,
                    "roomName": msg.roomName
                }
            }

            Vue.set(vueComponent.rooms, 0, vueComponent.rooms[0])
        }

        var onMessageReceived = function (msg) {
            var roomID = msg.roomID
            vueComponent.chatspreview[roomID].message = msg.message

            if (roomID === vueComponent.currentViewedRoomID) {
                vueComponent.currentChatContent.push({
                    "type": msg.type,
                    "fileHash": msg.fileHash,
                    "fileSize": msg.fileSize,
                    "message": msg.message,
                    "userID": msg.userID,
                    "time": msg.time,
                    "name": msg.name,
                })

            } else {
                vueComponent.addToRoomNotification(roomID)
            }

            if (msg.userID === '(%.Email%)') {
                scrollChatToBottom()
                return
            }

            playAudio.play();
            Vue.set(vueComponent.rooms, 0, vueComponent.rooms[0])
        }

        var onSocketOpened = function (msg) {
            if (msg.requests) {
                vueComponent.messages = []
                for (var i = 0; i < msg.requests.length; i++) {
                    var data = msg.requests[i]
                    var message = {
                        "requestingUserName": data.requestingUserName,
                        "requestingUserID": data.requestingUserID,
                        "roomName": data.roomName,
                        "roomID": data.roomID,
                    }

                    vueComponent.messages.push(message)
                }
            }

            if (msg.rooms) {
                vueComponent.rooms = []
                for (var i = 0; i < msg.rooms.length; i++) {
                    var data = msg.rooms[i]

                    var roomID = data.roomID
                    vueComponent.chatspreview[roomID] = {
                        "message": "",
                        "roomName": data.roomName
                    };

                    vueComponent.rooms.push(roomID)
                }
            }

            vueComponent.socketClosed = false
        }

        var onRequestDownload = function (e) {
            var id = e.fileName;
            vueComponent.downloadInfo[id].downloading = true;
            vueComponent.downloadInfo[id].completed = false;
            vueComponent.downloadInfo[id].chunks = e.chunks
            vueComponent.downloadInfo[id].fileType = e.fileType

            Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

            if (vueComponent.downloadInfo[id].chunk === vueComponent.downloadInfo[id].chunks) {
                downloadBlob(id)
                return
            }

            var message = {
                "userID": vueComponent.userID,
                "msgType": "DownloadFileChunk",
                "fileName": id,
                "compressedFileHash": vueComponent.downloadInfo[id].fileHash,
                "chunkIndex": vueComponent.downloadInfo[id].chunk,
            }
            socket.send(JSON.stringify(message))
        }

        // onDownloadFileChunk is called when client receives a file chunk (when user is downloading).
        // File chunk with hash is received which the client can verify it's sha256 sum.
        var onDownloadFileChunk = function (e) {
            var id = e.fileName
            // Confirm if it's the requested chunk and file sent integrity.
            // Stop downloading if file is corrupt so users can decide to re-request chunk.
            // TODO: Add a non-intrusive error message indicating file error download.
            if (e.fileHash !== CryptoJS.SHA256(e.fileChunk).toString() || e.chunkIndex !== vueComponent.downloadInfo[id].chunk) {
                vueComponent.downloadInfo[id].downloading = false
                Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

                return
            }

            e.fileChunk = e.fileChunk.substr(e.fileChunk.indexOf(',') + 1);

            var chunkSize = 125 * 1024;
            var byteCharacters = atob(e.fileChunk);
            var byteArrays = [];

            for (let offset = 0; offset < byteCharacters.length; offset += chunkSize) {
                const slice = byteCharacters.slice(offset, offset + chunkSize);
                const byteNumbers = new Array(slice.length);

                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }


            const blob = new Blob(byteArrays, { type: "" }); // use file type too
            vueComponent.downloadInfo[id].fileContent.push(blob)

            vueComponent.downloadInfo[id].progress = (vueComponent.downloadInfo[id].chunk / vueComponent.downloadInfo[id].chunks) * 100

            if (vueComponent.downloadInfo[id].chunk === vueComponent.downloadInfo[id].chunks) {
                downloadBlob(id)
                return
            }

            if (vueComponent.downloadInfo[id].downloading === false) {
                return
            }

            Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])
            vueComponent.downloadInfo[id].chunk++

            var message = {
                "userID": vueComponent.userID,
                "msgType": "DownloadFileChunk",
                "fileName": id,
                "compressedFileHash": vueComponent.downloadInfo[id].fileHash,
                "chunkIndex": vueComponent.downloadInfo[id].chunk,
            }

            socket.send(JSON.stringify(message))
        }

        // On final file upload, file checks if completed.
        // If complete, it sends the next chunk.
        var onUploadFileChunk = function (e) {
            var id = e.fileName
            if (vueComponent.downloadInfo[id].completed) {
                return
            }

            onSendFile(e)
        }


        var onSendFile = function (e) {
            var id = e.fileName
            var chunkSize = 125 * 1024;
            vueComponent.downloadInfo[id].chunk = e.nextChunk

            // If chunk is same as chunks, indicate file upload complete.
            if (vueComponent.downloadInfo[id].chunk >= vueComponent.downloadInfo[id].chunks) {
                vueComponent.downloadInfo[id].completed = true
                vueComponent.downloadInfo[id].downloading = false
                vueComponent.downloadInfo[id].chunk = 0
                vueComponent.downloadInfo[id].fileContent = []
                // Send upload success to server so that server can broadcast file to other
                // users in room.
                var message = {
                    "msgType": "FileUploadSuccess",
                    "userID": '(%.Email%)',
                    "name": '(%.Name%)',
                    "fileName": id,
                    "roomID": vueComponent.downloadInfo[id].roomID,
                    "fileSize": vueComponent.downloadInfo[id].fileSize,
                    "fileHash": vueComponent.downloadInfo[id].fileHash,
                }

                socket.send(JSON.stringify(message))
                Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])
                return
            }

            vueComponent.downloadInfo[id].progress = (vueComponent.downloadInfo[id].chunk / vueComponent.downloadInfo[id].chunks) * 100
            Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

            // Check if stop download was called.
            if (vueComponent.downloadInfo[id].downloading === false) {
                return
            }

            var offset = vueComponent.downloadInfo[id].chunk * chunkSize;
            var reader = new FileReader();
            reader.onload = function (event) {
                var data = event.target.result;
                var fileUniqueHash = CryptoJS.SHA256(data).toString();

                var message = {
                    "msgType": "UploadFileChunk",
                    "userID": '(%.Email%)',
                    "file": data,
                    "fileName": id,
                    "compressedFileHash": vueComponent.downloadInfo[id].fileHash,
                    "newChunkHash": fileUniqueHash,
                    "recentChunkHash": "",
                    "chunkIndex": vueComponent.downloadInfo[id].chunk,
                }

                if (vueComponent.downloadInfo[id].chunk === 0) {
                    // Send new file upload information to server, chunk == 0 indicates a new file.
                    socket.send(JSON.stringify(message));
                    return
                }

                var recentOffset = (vueComponent.downloadInfo[id].chunk - 1) * chunkSize;

                var recentFileReader = new FileReader();
                recentFileReader.onload = function (e) {
                    var recentData = e.target.result;
                    var recentFileUniqueHash = CryptoJS.SHA256(recentData).toString();

                    message.recentChunkHash = recentFileUniqueHash;
                    socket.send(JSON.stringify(message));
                }

                recentFileReader.readAsDataURL(vueComponent.downloadInfo[id].fileContent.slice(recentOffset, recentOffset + chunkSize));
            };

            reader.readAsDataURL(vueComponent.downloadInfo[id].fileContent.slice(offset, offset + chunkSize));
        }

        var downloadBlob = function (id) {
            vueComponent.downloadInfo[id].completed = true
            vueComponent.downloadInfo[id].downloading = false
            vueComponent.downloadInfo[id].progress = 0
            vueComponent.downloadInfo[id].chunk = 0
            Vue.set(vueComponent.currentChatContent, 0, vueComponent.currentChatContent[0])

            const blobB = new Blob(vueComponent.downloadInfo[id].fileContent, { type: vueComponent.downloadInfo[id].fileType });
            vueComponent.downloadInfo[id].fileContent = []
            let a = document.createElement("a");
            a.href = URL.createObjectURL(blobB);
            a.download = id;
            a.target = "_blank";
            a.click();
        }
    </script>
</body>

</html>